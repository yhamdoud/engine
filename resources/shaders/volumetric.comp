#version 460 core

#ifndef ENGINE_DEFINES
	#define LOCAL_SIZE 32
    #define CASCADE_COUNT 3
#endif

// TODO:
const float PI = 3.14159265359;

layout(local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE) in;

layout (std140, binding = 0) uniform Uniforms
{
	mat4 proj;
	mat4 proj_inv;
	mat4 view_inv;
    uvec2 size;
    int step_count;
    float scatter_intensity;
    vec3 sun_dir;
    vec3 sun_color;
} u;

layout (binding = 1) uniform sampler2D u_g_depth;
layout (binding = 2) uniform sampler2DArrayShadow u_shadow_map;

layout(binding = 3, rgba16f) restrict uniform image2D u_read;


#if CASCADE_COUNT > 1
uniform float u_cascade_distances[CASCADE_COUNT];
#endif

uniform mat4 u_light_transforms[CASCADE_COUNT];

uint calculate_cascade_index(vec3 pos)
{
#if CASCADE_COUNT > 1
    uint cascade_idx = CASCADE_COUNT - 1;
    for (int i = 0; i < CASCADE_COUNT; i++)
    {
        // Sign change
        if (-pos.z < u_cascade_distances[i])
        {
            cascade_idx = i;
            break;
        }
    }
    return cascade_idx;
#else
    return 0;
#endif
}

float linearize_depth(float depth, mat4 proj)
{
    return -proj[3][2] / (2. * depth - 1. + proj[2][2]);
}

float henyey_greenstein(float theta, float g)
{
    return (1. - g*g) / (4. * PI * pow(1. + g*g - 2.*g * cos(theta), 1.5));
}

void main()
{
    const ivec2 gid = ivec2(gl_GlobalInvocationID.xy);
    const uvec2 lid = gl_LocalInvocationID.xy;
	const uint lidx = gl_LocalInvocationIndex;

    vec2 tex_coords = (vec2(gid) + 0.5) / vec2(u.size);

    vec4 pos_ndc = vec4(tex_coords * 2. - 1., 0., 1.);
    vec4 pos_view = u.proj_inv * pos_ndc;
    vec3 view_ray = vec3(pos_view.xy / pos_view.z, 1.);

    vec3 ray_end = view_ray * linearize_depth(texture(u_g_depth, tex_coords).r, u.proj);
    vec3 ray_origin = vec3(0.);

	vec3 ray = ray_end - ray_origin;
	float ray_len = length(ray);
	vec3 ray_dir = ray / ray_len;

	float step_size = ray_len / u.step_count;

	vec3 ray_step = step_size * ray_dir;

    float fog = 0.;

	vec3 pos = ray_origin;

	for (int i = 0; i < u.step_count; i++)
	{
        uint cascade_idx = calculate_cascade_index(pos);
        vec4 pos_light = u_light_transforms[cascade_idx] * u.view_inv * vec4(pos, 1.);
        pos_light.xyz /= pos_light.w;

        float shadow = 0;

        if (pos_light.z < 1.)
        {
            vec3 foo = pos_light.xyz * 0.5 + 0.5;

            shadow = texture(u_shadow_map, vec4(foo.xy, cascade_idx, foo.z));
        }

        fog += henyey_greenstein(dot(ray_dir, u.sun_dir), u.scatter_intensity) * shadow;

        pos += ray_step;
	}


    vec4 color = imageLoad(u_read, gid);

    color.xyz += u.sun_color * (fog / u.step_count);

    imageStore(u_read, gid, color);
}